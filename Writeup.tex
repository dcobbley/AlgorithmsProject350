\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,tabu,enumerate,tikz}
\usepackage[margin=1in]{geometry}
\usepackage{verbatim} % Allows Multi-line comments 
\usepackage{multicol}

\usetikzlibrary{automata,positioning}
\newcommand{\encode}[1]{\langle #1 \rangle}
  
\title{Comparison of Dijkstra's and Bellman-Ford \\ CS 350 Algorithms Project}
\author{Katie Abrahams, David Cobbley, Andrew Qin}
\date{March 12 2015}

\begin{document}

\maketitle

\section{Introduction}
For our algorithm comparison and testing, we chose to compare two shortest-path algorithms.  After examining different algorithms that found shortest path between nodes of a graph, we chose Bellman-Ford and Dijkstra's algorithms.
We compared the Bellman-Ford and Dijkstra's shortest path algorithm on sets of data and compared several sets of metrics to see which algorithm is more efficient.

\section{Background info}
The Dijkstra's algorithm we selected has a time complexity of $O((|V|+|E|)+log|V|)$.

Correctness: 

Completeness:

Based on the proof seen in Cormen, et al, and our adaptations for the code.

Psuedocode:
\begin{verbatim}

\end{verbatim}

Our Bellman-Ford algorithm has a time complexity of $O(|V||E|)$.

Correctness:

Completeness:

Based on the proof seen in Cormen, et al.

Psuedocode:
\begin{verbatim}

\end{verbatim}
\section{Testing Procedure}
We modified code for Dijktra's and Bellman-Ford algorithms found online (listed in the Sources section), and ran tests to compare the time complexity of each algorithm with controlled data sets.  We also controlled for differences in operating system efficiency; we chose Linux as our testing platform.  In the course of testing, we also used Python metrics tools (cProfile and time).  Once we located the source code we chose to modify, we first ran preliminary tests for correctness and rough time estimates.  Both the Python time and cProfile tools were run from the command line, to verify program correctness and completeness at the most basic level.  Once the raw source code passed these tests, we could modify the code.
To modify the code, we changed the data reading functionality to read in large data sets (>100,000 nodes at a base level).  We needed a large data set to make a meaningful time comparison.
 We also modified the code to read in data sets in the same way, so that our tests would not be affected by differences in data processing.
\section{Analysis}

\section{Sources}

We used this source code for our Bellman-Ford:
\begin{verbatim}
https://github.com/mneedham/algorithms2/tree/master/shortestpath
\end{verbatim}


\begin{verbatim}
http://www.ijstr.org/final-print/june2013/A-Review-And-Evaluations-Of-Shortest-Path-Algorithms.pdf

http://www.sciencedirect.com.proxy.lib.pdx.edu/science/article/pii/S0304397502006138#

http://www.sciencedirect.com.proxy.lib.pdx.edu/science/article/pii/S0196677403000464

ACM
http://dl.acm.org.proxy.lib.pdx.edu/dl.cfm

Thomas H. Cormen, Clifford Stein, Ronald L. Rivest, and Charles E. Leiserson.
2001. Introduction to Algorithms (2nd ed.). McGraw-Hill Higher Education. 
\end{verbatim}
\end{document}
