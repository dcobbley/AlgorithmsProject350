\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,amsthm,tabu,enumerate,tikz}
\usepackage[margin=1in]{geometry}
\usepackage{verbatim} % Allows Multi-line comments 
\usepackage{multicol}
\usepackage{setspace}
\onehalfspacing
\usepackage{listings}
\lstset{
basicstyle=\small\ttfamily,
columns=flexible,
breaklines=true
}

\usetikzlibrary{automata,positioning}
\newcommand{\encode}[1]{\langle #1 \rangle}
  
\title{Comparison of Dijkstra's and Bellman-Ford \\ CS 350 Algorithms Project}
\author{Katie Abrahams, David Cobbley, Andrew Qin}
\date{March 12 2015}

\begin{document}

\maketitle

\section{Introduction}
For our algorithm comparison and testing, we chose to compare two shortest-path algorithms.  After examining different algorithms that found shortest path between nodes of a graph, we chose Bellman-Ford and Dijkstra's algorithms.
We compared the Bellman-Ford and Dijkstra's shortest path algorithm on sets of data and compared several sets of metrics to see which algorithm is more efficient.  To supplement our own testing, we researched the two algorithms and recorded their textbook time complexities to compare with our own tests.

\section{Terms}
In a directed graph $G=(V,E)$ with $V$ vertices and $E$ weighted edges:

The shortest path weight from $u$ to $v$:

$\delta(u,v) = \begin{cases}
\text{min} \hspace{5 pt} \{w(p):u\overset{p}{\leadsto}v\} \hspace{5 pt} \text{if there is a path from $u$ to $v$}\\
\infty \hspace{5 pt} \text{otherwise}
\end{cases}$
\\
\\
Weight $w(p)$ of path $p$:

$w(p)=\displaystyle\sum_{i=1}^{k} w(v_{i-1},v_{i})$
\\
\\
(Cormen, 2001)
\section{Background info}
The Dijkstra's algorithm we selected has a time complexity of $O((|V|+|E|)+log|V|)$.
The algorithm used here was the version modified from Dijkstra's original algorithm, and uses a min-priority queue and a Fibonacci heap to improve time complexity.  Dijkstra's as used here is a single-source shortest path algorithm.  It builds a shortest path tree to find the shortest path between a node and all other nodes in the graph it is traversing. (Kairanbay, 2013)


Correctness: 

Inductive proof:

Invariant: For each node n $\in$ G, d(n) is the length of the shortest m $\rightarrow$ n path.

Base case: $\mid$ G $\mid$  = 1

Inductive hypothesis: Assume this is true for $\mid$ G $\mid$ = k $\geq$ 1.

1. Let v be next node added to G, and let n $\rightarrow$ v be the chosen edge.

2. The shortest m $\rightarrow$ n path plus (n, v) is an m $\rightarrow$ v path of length $\pi$(v)

3. Consider any m $\rightarrow$ v path P.
    We'll see that it's no shorter than $\pi$(v)

4. Let x $\rightarrow$ y be the first edge in P that leaves G, 
    and let P' be the sub-path to x.

5. Path P is too long as soon as it leaves G.

$l(P) \geq l(P') + l(x,y) \geq d(x) + l(x,y) \geq \pi(y) \geq \pi(v)$

(Harel, 1980)


Completeness:
Dijkstra's algorithm is complete based on the fact that it will always terminate and have valid output given a valid input.
The algorithm will always terminate given valid input because Dijkstra's algorithm considers all vertices of the graph. As such, the set $V$ of all vertices, will eventually match the set of vertices that are analyzed by the algorithm for building shortest paths.  Once all input has been consumed, the algorithm alchitecture guarentees a valid output for a given valid input.
\\Based on the proof seen in Cormen (2001), Harel(1980),  and our adaptations for the code.

Psuedocode:
\begin{verbatim}

\end{verbatim}

Our Bellman-Ford algorithm has a time complexity of $O(|V||E|)$.

Correctness:

Completeness:
\\Based on the proof seen in Cormen (2001).

Psuedocode:\\
for $v \in V\\
 v.d = \infty\\
 v.\pi = \text{None}\\
s.d = 0\\
\text{for} i \text{from} 1 \text{to} \mid V \mid -1:\\
 \text{for} (u,v) \in E:\\
  \text{relax}(u,v):\\
   \text{if} v.d > u.d + w(u,v):\\
	v.d = u.d + w(u,v)\\
	 v.\pi = u$\\
\begin{verbatim}

\end{verbatim}
\section{Testing Procedure}
We modified code for Dijktra's and Bellman-Ford algorithms found online (listed in the Sources section), and ran tests to compare the time complexity of each algorithm with controlled data sets.  We also controlled for differences in operating system efficiency; we chose Linux as our testing platform.  In the course of testing, we also used Python metrics tools (cProfile and time).  Once we located the source code we chose to modify, we first ran preliminary tests for correctness and rough time estimates.  Both the Python time and cProfile tools were run from the command line, to verify program correctness and completeness at the most basic level.  Once the raw source code passed these tests, we could modify the code.
To modify the code, we changed the data reading functionality to read in large data sets (>100,000 nodes at a base level).  We needed a large data set to make a meaningful time comparison.
 We also modified the code to read in data sets in the same way, so that our tests would not be affected by differences in data processing.
\section{Analysis}

\section{Sources}

We used this source code for our Bellman-Ford:
\begin{verbatim}
https://github.com/mneedham/algorithms2/tree/master/shortestpath
\end{verbatim}


\begin{lstlisting}
[1] Cormen, Thomas H., Clifford Stein, Ronald L. Rivest, and Charles E. Leiserson.
2001. Introduction to Algorithms (2nd ed.). McGraw-Hill Higher Education. 

[2] Harel, David, Proving the correctness of regular deterministic programs: A unifying survey using dynamic logic, Theoretical Computer Science, Volume 12, Issue 1, September 1980, Pages 61-81, ISSN 0304-3975, http://dx.doi.org/10.1016/0304-3975(80)90005-5.
http://www.sciencedirect.com/science/article/pii/0304397580900055

[3] Magzhan, Kairanbay, and Hajar Mat Jani, 'A Review And Evaluations Of Shortest Path Algorithms'. International Journal of Scientific & Technology Research, Volume 2, Issue 6, June 2013, Pages 99-104, ISSN 2277-8616. Web. 15 Feb. 2015.
http://www.ijstr.org/final-print/june2013/A-Review-And-Evaluations-Of-Shortest-Path-Algorithms.pdf

[4] Meyer, Ulrich, 'Average-case complexity of single-source shortest-paths algorithms: lower and upper bounds', Journal of Algorithms, Volume 48, Issue 1, August 2003, Pages 91-134, ISSN 0196-6774, http://dx.doi.org/10.1016/S0196-6774(03)00046-4.
http://www.sciencedirect.com/science/article/pii/S0196677403000464

[5] Saunders, Shane, and Tadao Takaoka, 'Improved shortest path algorithms for nearly acyclic graphs'. Theoretical Computer Science, Volume 293, Issue 3, 9 February 2003, Pages 535-556, ISSN 0304-3975, http://dx.doi.org/10.1016/S0304-3975(02)00613-8.
http://www.sciencedirect.com/science/article/pii/S0304397502006138

[6] ACM Digital Library
dl.acm.org.proxy.lib.pdx.edu,. (2015). Retrieved 11 February 2015

\end{lstlisting}
\end{document}
